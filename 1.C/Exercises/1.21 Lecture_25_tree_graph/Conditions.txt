Задача 1
Реализирайте ваша имплементация на двоично дърво с цели числа.
● Дефинирайте функции за добавяне и премахване на върхове от дървото.

Задача 2 (продължение от задача 1)
● Дефинирайте функция, която обхожда и принтира всеки елемент от дървото в избрана от вас
последователност. (inorder, preorder, postorder, ..)

Задача 3 (продължение от задача 1)
● Дефинирайте функция, за търсене на стойност на връх в дървото.

Задача 4 (продължение от задача 1)
● Дефинирайте функция, която връща височината на дървото
Задачи за самоподготовка

Задача 5 (продължение от задача 1)
● Дефинирайте функция, която връща сумата от всички елементи на дървото

Задача 6 (продължение от задача 1)
● Дефинирайте функция, която връща най-малката и най-голямата стойност на
елемент от дървото. Какви начини има да върнем и двете от една функция?

Задача 7 (продължение от задача 1)
● Дефинирайте функция, която проверява дали дървото е binary search tree (дали
върховете са “сортирани отляво-надясно” по стойност)
Задачи за самоподготовка

Задача 8
Реализирайте ваша имплементация на граф, в който всеки връх е град(има стойност - име на град)
и в който имаме тегло на ребрата - дължината на пътя между два града.
● Дефинирайте функции за добавяне и премахване на нови градове и за добавяне и премахване
на нови пътища между два града

Задача 9 (продължение от задача 8)
● Дефинирайте функция, която проверява дали има път от един град до друг (път в граф - може
да минава през няколко града)

Задача 10 (продължение от задача 8)
● Дефинирайте функция, която намира път от един връх до друг. Mоже и най-прекия, например с
алгоритъма на Дийкстра (Dijkstra's Algorithm)