Задачи за самоподготовка

Задача 1
Дефинирайте нов тип - динамичен масив(vector) с указатели към стрингове (към началото им - char*).
Дефинирайте следните интерфейсни функции (”my_” e примерно име на библиотека. Би могло и да е “str”,
тъй като е списък с char* елементи):
● Функция за инициализация на членовете на масива:
void my_vector_init(my_vector v);
● Приемлив интерфейс е и : void my_vector_init(my_vector *v);
● Същото важи и за останалите функции.
● Функция за проверка на това дали масивът е празен:
_Bool my_vector_empty(my_vector v);
● Функция за премахване на всички елементи от масива:
void my_vector_clear(my_vector v);
● Функция, която връща броя на елементите на масива:
size_t my_vector_size(my_vector v);
Задачи за самоподготовка

Задача 2 (продължение от задача 1)
● Дефинирайте функции за добавяне на елементи на последна и на конкретна
позиция в динамичния масив:
void my_vector_push_back(char *data, my_vector vec);
void my_vector_insert(char *data, my_vector vec, size_t pos);

Задача 3 (продължение от задача 1)
● Дефинирайте функции за изтриване на елементи на последна и на конкретна
позиция в списъка:
void my_vector_pop_back(my_vector vec);
void my_vector_erase(my_vector vec, size_t pos);
Задачи за самоподготовка

Задача 4 (продължение от задача 1)
● Дефинирайте функция, която връща текущия капацитет на динамичния масив:
size_t my_vector_capacity(my_vector vec);
● Дефинирайте функция, която променя капацитета на динамичен масив.
void my_vector_reserve(my_vector vec, size_t minCapacity);
Ако новоподаденият капацитет е по-голям от текущия, функцията трябва да
реалокира достатъчно памет за minCapacity на брой елемента (може и повече).
Ако новоподаденият капацитет е по-малък от текущия - функцията не прави нищо
(текущият капацитет се запазва, не се намалява; не се алокира/деалокира/реалокира
памет)
Задачи за самоподготовка

Задача 5 (продължение от задача 1)
● Дефинирайте функции за промяна на броя на елементите на динамичния масив:
void my_vector_resize(my_vector vec, size_t elementsCount);
void my_vector_resize_init(my_vector vec, size_t elementsCount,char *defaultValue);
Ако elementsCount е по-малък от текущия размер, съдържанието на динамичния
масив става първите elementsCount и останалите се унищожават.
Ако elementsCount е по-голямо от текущия размер, динамичният масив се разширява
до elementsCount брой елементи, като:
● my_vector_resize инициализира новите елементи на NULL
● my_vector_resize_init инициализира новите елементи на стойността на 3тия си
параметър: defaultValue
Задачи за самоподготовка

Задача 6 (продължение от задача 1)
● Дефинирайте функции за достъп до първия, последния и конкретен елемент от масива:
char* my_vector_front(my_vector vec);
char* my_vector_back(my_vector vec);
char* my_vector_at(my_vector vec, size_t index);

Задача 7 (продължение от задача 1)
● Дефинирайте функция за итериране на елементите на масива, която приема указател към друга функция, подадена
от клиента, която извършва желаните операции на всеки отделен елемент от списъка.
void my_vector_iterate(my_vector vec, void (*iterFunc)(char*));
Функцията за итериране трябва да извиква подадената й като аргумент функция за всеки елемент на списъка.
Задача 8 (продължение от задача 1)

● Дефинирайте функция за сортиране на елементите на масива по зададен предикат(параметър - указател към
функция, която сравнява два елемента и връща -1, 0 или 1.
void my_vector_sort(my_vector vec, //..